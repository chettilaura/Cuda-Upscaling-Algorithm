
// char col = blockIdx.x % 3;

// Load the input image into shared memory
// in_img_shared[threadIdx.x] = input[blockIdx.x/3*blockDim.x + threadIdx.x/tileDim*dimB + threadIdx.x * 3 + col];
// in_img_shared[threadIdx.x] = input[blockIdx.x / 3 * 96 + threadIdx.x / 32 * dimB + (threadIdx.x % 32) * 3 + col];
// in_img_shared[threadIdx.x] = input[  ]; // Either this one
/*in_img_shared[threadIdx.x] = input[col + (threadIdx.x % 32) * 3 + /*(threadIdx.x/32)*dimB + */ blockIdx.x / 96 * dimB + (blockIdx.x % 96) * 32]; // Or this one are wrong
__syncthreads();

// Compute the convolution if the thread is inside the image
// if (threadIdx.x % 32 < tileDim && threadIdx.x < (tileDim * 32))
if (threadIdx.x < tileDim * tileDim)
{
    for (int i = 0; i < dimKernel; i++)
    {
        for (int j = 0; j < dimKernel; j++)
        {
            sum += in_img_shared[threadIdx.x + i * tileDim + j] * d_kernel[i * dimKernel + j];
        }
    }

    if (idx == 0)
        printf("%f", sum);
    __syncthreads();
    output[blockIdx.x / (3 * tileDim) * dim + (blockIdx.x % (3 * tileDim)) * tileDim + col + (threadIdx.x % tileDim) * 3 /*+(threadIdx.x/tileDim)*dim*/] = (unsigned char)sum;
    // output[blockIdx.x/3*blockDim.x + threadIdx.x/tileDim*dim + threadIdx.x * 3 + col] = (unsigned char)sum; // Or this one are wrong
    // output[blockIdx.x / 3 * 96 + threadIdx.x / 32 * dim + (threadIdx.x ) * 3 + col] = (unsigned char)sum; // Or this one are wrong
}
/*if (threadIdx.x < tileDim * tileDim)
{
    output[blockIdx.x / 3 * (tileDim * 3) + threadIdx.x / tileDim * dim + (threadIdx.x % tileDim) * 3 + col] = in_img_shared[threadIdx.x];
}*/
}